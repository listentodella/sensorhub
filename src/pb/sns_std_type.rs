// This file is @generated by prost-build.
/// Represents an unique Sensor
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnsStdSuid {
    #[prost(fixed64, tag = "1")]
    pub suid_low: u64,
    #[prost(fixed64, tag = "2")]
    pub suid_high: u64,
}
/// Represents an attribute value
/// Attribute values may be a single value, array of simple values, or
/// an array of complex tuples
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnsStdAttrValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<sns_std_attr_value::Data>,
}
/// Nested message and enum types in `sns_std_attr_value`.
pub mod sns_std_attr_value {
    /// "data" submessage optional to support recursion
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// option (nanopb_msgopt).no_unions = true;
        #[prost(oneof = "data::Value", tags = "1, 2, 3, 4, 5")]
        pub value: ::core::option::Option<data::Value>,
    }
    /// Nested message and enum types in `data`.
    pub mod data {
        /// option (nanopb_msgopt).no_unions = true;
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            Subtype(super::super::SnsStdAttrValue),
            #[prost(string, tag = "2")]
            Str(::prost::alloc::string::String),
            #[prost(float, tag = "3")]
            Flt(f32),
            #[prost(sfixed64, tag = "4")]
            Sint(i64),
            #[prost(bool, tag = "5")]
            Boolean(bool),
        }
    }
}
/// An individual attribute from a Sensor
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnsStdAttr {
    /// A standard list of attributes is available within sns_std_sensor_attr_id
    /// Additional attributes may be defined by sensors, using the format:
    /// <SENSOR_PROTO_NAME>_ATTRID_<ATTR_NAME> (e.g. SNS_ACCEL_ATTRID_ODR)
    /// Additional IDs must fall within the range of 1024-2047
    #[prost(int32, optional, tag = "1")]
    pub attr_id: ::core::option::Option<i32>,
    /// Attribute value
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<SnsStdAttrValue>,
}
/// Error codes
///
///    option (nanopb_enumopt).long_names = false;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdError {
    /// No error occurred; success.
    NoError = 0,
    /// Unfixable or internal error occurred.
    Failed = 1,
    /// This API is not supported or is not implemented.
    NotSupported = 2,
    /// Message contains invalid data type,
    /// e.g., unknown message ID, unknown registry group, or unexpected
    /// Sensor UID.
    InvalidType = 3,
    /// Catastrophic error; expect no further data
    InvalidState = 4,
    /// One or more argument values were outside of the valid range
    InvalidValue = 5,
    /// This operation is not available at this time
    NotAvailable = 6,
    /// This action was rejected due to the current policy settings
    Policy = 7,
}
impl SnsStdError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoError => "SNS_STD_ERROR_NO_ERROR",
            Self::Failed => "SNS_STD_ERROR_FAILED",
            Self::NotSupported => "SNS_STD_ERROR_NOT_SUPPORTED",
            Self::InvalidType => "SNS_STD_ERROR_INVALID_TYPE",
            Self::InvalidState => "SNS_STD_ERROR_INVALID_STATE",
            Self::InvalidValue => "SNS_STD_ERROR_INVALID_VALUE",
            Self::NotAvailable => "SNS_STD_ERROR_NOT_AVAILABLE",
            Self::Policy => "SNS_STD_ERROR_POLICY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_ERROR_NO_ERROR" => Some(Self::NoError),
            "SNS_STD_ERROR_FAILED" => Some(Self::Failed),
            "SNS_STD_ERROR_NOT_SUPPORTED" => Some(Self::NotSupported),
            "SNS_STD_ERROR_INVALID_TYPE" => Some(Self::InvalidType),
            "SNS_STD_ERROR_INVALID_STATE" => Some(Self::InvalidState),
            "SNS_STD_ERROR_INVALID_VALUE" => Some(Self::InvalidValue),
            "SNS_STD_ERROR_NOT_AVAILABLE" => Some(Self::NotAvailable),
            "SNS_STD_ERROR_POLICY" => Some(Self::Policy),
            _ => None,
        }
    }
}
/// The enum contains all the processor types supported.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdClientProcessor {
    Ssc = 0,
    Apss = 1,
    Adsp = 2,
    Mdsp = 3,
    Cdsp = 4,
}
impl SnsStdClientProcessor {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ssc => "SNS_STD_CLIENT_PROCESSOR_SSC",
            Self::Apss => "SNS_STD_CLIENT_PROCESSOR_APSS",
            Self::Adsp => "SNS_STD_CLIENT_PROCESSOR_ADSP",
            Self::Mdsp => "SNS_STD_CLIENT_PROCESSOR_MDSP",
            Self::Cdsp => "SNS_STD_CLIENT_PROCESSOR_CDSP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_CLIENT_PROCESSOR_SSC" => Some(Self::Ssc),
            "SNS_STD_CLIENT_PROCESSOR_APSS" => Some(Self::Apss),
            "SNS_STD_CLIENT_PROCESSOR_ADSP" => Some(Self::Adsp),
            "SNS_STD_CLIENT_PROCESSOR_MDSP" => Some(Self::Mdsp),
            "SNS_STD_CLIENT_PROCESSOR_CDSP" => Some(Self::Cdsp),
            _ => None,
        }
    }
}
