// This file is @generated by prost-build.
/// Sensor stream configuration request
/// or configuration change message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnsStdSensorConfig {
    /// Sample rate in Hz.
    #[prost(float, optional, tag = "1")]
    pub sample_rate: ::core::option::Option<f32>,
}
/// Sensor data event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnsStdSensorEvent {
    /// Output data field for all Sensor.
    #[prost(float, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<f32>,
    /// Event sample status.\[default = SNS_STD_SENSOR_SAMPLE_STATUS_UNRELIABLE\]
    #[prost(enumeration = "SnsStdSensorSampleStatus", optional, tag = "2")]
    pub status: ::core::option::Option<i32>,
}
/// Sensor stream configuration event
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SnsStdSensorConfigEvent {
    /// Current sample rate in Hz
    #[prost(float, optional, tag = "1")]
    pub sample_rate: ::core::option::Option<f32>,
}
/// Physical sensor stream configuration. This message reflects the current
/// configuration of the physical sensor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnsStdSensorPhysicalConfigEvent {
    /// Current sample rate in Hz for streaming sensors or highest rate of value
    /// change for on-change sensors. 0 if sensor is disabled.
    /// Note: if stream will be synchronized via S4S or I3C, this is the sample
    /// rate after synchronization is complete.
    #[prost(float, optional, tag = "1")]
    pub sample_rate: ::core::option::Option<f32>,
    /// Current hardware water mark setting. 1 if FIFO not in use.
    #[prost(uint32, optional, tag = "2")]
    pub water_mark: ::core::option::Option<u32>,
    /// Sensor sample value min and max range
    /// \[(nanopb).max_count = 2\];
    #[prost(float, repeated, tag = "3")]
    pub range: ::prost::alloc::vec::Vec<f32>,
    /// Sensor sample value Resolution
    #[prost(float, optional, tag = "4")]
    pub resolution: ::core::option::Option<f32>,
    /// Sensor operation mode
    /// If all requests to the sensor are passive then it shall use
    /// operating_mode = "OFF"
    #[prost(string, optional, tag = "5")]
    pub operation_mode: ::core::option::Option<::prost::alloc::string::String>,
    /// Sensor active current in uA
    #[prost(uint32, optional, tag = "6")]
    pub active_current: ::core::option::Option<u32>,
    /// Sensor streaming is synchronized via methods like S4S and/or I3C.
    /// Note: if the stream is not yet synchronized, this field should be
    /// false, and an additional config event sent with stream_is_synchronous
    /// set to true once the clocks have been synchronized.
    #[prost(bool, optional, tag = "7")]
    pub stream_is_synchronous: ::core::option::Option<bool>,
    /// Sensor has enabled Data Ready Interrupt
    #[prost(bool, optional, tag = "8")]
    pub dri_enabled: ::core::option::Option<bool>,
    /// Current DAE water mark setting. 0 if non-DAE sensor.
    #[prost(uint32, optional, tag = "9")]
    pub dae_watermark: ::core::option::Option<u32>,
    /// The sync anchor is only valid for polled or synchronized sensors.
    /// It is a timestamp of a future (or past) sns_std_sensor_event.
    /// For synchronous sensors: this may be used by clients to determine the
    /// synchronized timeline before it is synchronized.
    #[prost(uint64, optional, tag = "10")]
    pub sync_ts_anchor: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdSensorMsgid {
    /// option (nanopb_enumopt).long_names = false;
    Reserved = 0,
    /// Uses message: sns_std_sensor_config
    /// Purpose:
    ///    1. A stream request from a client to a sensor.
    ///    2. A config/ack event from a sensor to the client.
    SnsStdSensorConfig = 513,
    /// Does not use any message body.
    /// Purpose:
    ///    1. An enable request from a client to an on-change sensor.
    ///       Subsequent request from same client will be treated as NOP
    ///    2. A config/ack event from an on-change sensor to the client.
    SnsStdOnChangeConfig = 514,
    /// Uses message: sns_std_sensor_physical_config_event
    /// Purpose: A configuration event from a Physical Sensor (streaming and event)
    ///           to the client.
    SnsStdSensorPhysicalConfigEvent = 768,
    /// Uses message: sns_std_sensor_event
    /// Purpose: A data event from a Sensor.
    SnsStdSensorEvent = 1025,
}
impl SnsStdSensorMsgid {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Reserved => "SNS_STD_SENSOR_MSGID_RESERVED",
            Self::SnsStdSensorConfig => "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_CONFIG",
            Self::SnsStdOnChangeConfig => "SNS_STD_SENSOR_MSGID_SNS_STD_ON_CHANGE_CONFIG",
            Self::SnsStdSensorPhysicalConfigEvent => {
                "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_PHYSICAL_CONFIG_EVENT"
            }
            Self::SnsStdSensorEvent => "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_EVENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_SENSOR_MSGID_RESERVED" => Some(Self::Reserved),
            "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_CONFIG" => {
                Some(Self::SnsStdSensorConfig)
            }
            "SNS_STD_SENSOR_MSGID_SNS_STD_ON_CHANGE_CONFIG" => {
                Some(Self::SnsStdOnChangeConfig)
            }
            "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_PHYSICAL_CONFIG_EVENT" => {
                Some(Self::SnsStdSensorPhysicalConfigEvent)
            }
            "SNS_STD_SENSOR_MSGID_SNS_STD_SENSOR_EVENT" => Some(Self::SnsStdSensorEvent),
            _ => None,
        }
    }
}
/// Status for each sensor sample
///
/// option (nanopb_enumopt).long_names = false;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdSensorSampleStatus {
    /// Sample is unreliable.
    Unreliable = 0,
    /// Sample is low accuracy.
    AccuracyLow = 1,
    /// Sample is medium accuracy.
    AccuracyMedium = 2,
    /// Sample is high accuracy.
    AccuracyHigh = 3,
}
impl SnsStdSensorSampleStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unreliable => "SNS_STD_SENSOR_SAMPLE_STATUS_UNRELIABLE",
            Self::AccuracyLow => "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_LOW",
            Self::AccuracyMedium => "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_MEDIUM",
            Self::AccuracyHigh => "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_SENSOR_SAMPLE_STATUS_UNRELIABLE" => Some(Self::Unreliable),
            "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_LOW" => Some(Self::AccuracyLow),
            "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_MEDIUM" => Some(Self::AccuracyMedium),
            "SNS_STD_SENSOR_SAMPLE_STATUS_ACCURACY_HIGH" => Some(Self::AccuracyHigh),
            _ => None,
        }
    }
}
/// Attribute IDs available for use by Sensors
/// Some are marked as REQUIRED, and must be published by every Sensor.  Others
/// are OPTIONAL, and may be only necessary for physical Sensors.
///
/// Each Sensor may define their own custom attributes, using the form:
/// <proto_name>_attr_id.  Attribute IDs have the following reserved ranges:
/// 0-511 : Held for sns_std_sensor_attr_id
/// 512-1023 : Reserved for internal QTI use
/// 1024-1535 : Available for use by Sensor developers
///
/// option (nanopb_enumopt).long_names = false;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdSensorAttrId {
    /// REQUIRED
    /// String
    /// Human-readable sensor name
    SnsStdSensorAttridName = 0,
    /// REQUIRED
    /// String
    /// Human-readable vendor name
    SnsStdSensorAttridVendor = 1,
    /// REQUIRED
    /// String
    /// Data Type used by this Sensor
    SnsStdSensorAttridType = 2,
    /// REQUIRED
    /// Boolean
    /// Whether this Sensor is available for clients
    SnsStdSensorAttridAvailable = 3,
    /// REQUIRED
    /// Integer
    /// Sensor version
    SnsStdSensorAttridVersion = 4,
    /// REQUIRED
    /// \[String\]
    /// .proto files specifying the incoming request and outgoing event messages
    SnsStdSensorAttridApi = 5,
    /// OPTIONAL
    /// \[Float\]
    /// Supported sample rates in Hz
    SnsStdSensorAttridRates = 6,
    /// OPTIONAL
    /// \[Float\]
    /// Supported resolutions
    SnsStdSensorAttridResolutions = 7,
    /// OPTIONAL
    /// Integer
    /// Supported FIFO depth in number of samples
    SnsStdSensorAttridFifoSize = 8,
    /// OPTIONAL
    /// \[Integer\]
    /// Active currents in uA for all sns_attr_op_modes. Length of the array
    /// of active currents must match the length of the array of operation modes.
    SnsStdSensorAttridActiveCurrent = 9,
    /// OPTIONAL
    /// Integer
    /// Inactive current in uA
    SnsStdSensorAttridSleepCurrent = 10,
    /// OPTIONAL
    /// \[{float,float}\]
    /// Supported operating ranges
    SnsStdSensorAttridRanges = 11,
    /// OPTIONAL
    /// String
    /// Operating Modes ("LPM", "HIGH_PERF", "NORMAL", "OFF")
    SnsStdSensorAttridOpModes = 12,
    /// OPTIONAL
    /// Boolean
    /// Boolean: Whether the Sensor supports Data Ready Interrupt (DRI).
    SnsStdSensorAttridDri = 13,
    /// OPTIONAL
    /// Boolean
    /// Whether a Sensor support synchronized streaming.
    SnsStdSensorAttridStreamSync = 14,
    /// OPTIONAL
    /// Integer
    /// Encoded message size of the data event generated most often by the Sensor
    SnsStdSensorAttridEventSize = 15,
    /// REQUIRED
    /// Integer: sns_std_sensor_stream_type
    /// Streaming Type
    SnsStdSensorAttridStreamType = 16,
    /// OPTIONAL
    /// Boolean
    /// Whether this Sensor is dynamic (connected/disconnected at runtime)
    SnsStdSensorAttridDynamic = 17,
    /// OPTIONAL
    /// Integer
    /// When multiple Sensors of the same hardware exist, this attribute differentiates.
    SnsStdSensorAttridHwId = 18,
    /// OPTIONAL
    /// Integer: sns_std_sensor_rigid_body_type
    /// The rigid body on which the Sensor is placed.
    SnsStdSensorAttridRigidBody = 19,
    /// OPTIONAL
    /// float\[12\]
    /// Location and orientation of sensor element in the device frame.
    SnsStdSensorAttridPlacement = 20,
    /// OPTIONAL
    /// Boolean
    /// Boolean: True for a physical sensor
    SnsStdSensorAttridPhysicalSensor = 21,
    /// OPTIONAL
    /// \[Integer\]
    /// List of supported self-test types from sns_physical_sensor_test_type.
    SnsStdSensorAttridPhysicalSensorTests = 22,
    /// OPTIONAL
    /// Float
    /// Sensors chosen resolution in it's engineering units.
    SnsStdSensorAttridSelectedResolution = 23,
    /// OPTIONAL
    /// float\[2\]
    /// Sensors chosen {min, max} range in it's engineering units.
    SnsStdSensorAttridSelectedRange = 24,
    /// OPTIONAL
    /// \[float\]
    /// List of additional sample rates for low latency clients in Hz.
    /// These are additional rates for low latency clients extended from list
    /// of rates published in attribute SNS_STD_SENSOR_ATTRID_RATES.
    /// This is supported for internal clients only. External clients shall not use this API.
    SnsStdSensorAttridAdditionalLowLatencyRates = 25,
    /// OPTIONAL
    /// Boolean
    /// Boolean: True if the sensor supports passive request, False otherwise.
    /// If this attribute is not supported, then the sensor does not support passive requests.
    /// Sensors that do not support passive requests, will service all requests as active requests.
    SnsStdSensorAttridPassiveRequest = 26,
}
impl SnsStdSensorAttrId {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SnsStdSensorAttridName => "SNS_STD_SENSOR_ATTRID_NAME",
            Self::SnsStdSensorAttridVendor => "SNS_STD_SENSOR_ATTRID_VENDOR",
            Self::SnsStdSensorAttridType => "SNS_STD_SENSOR_ATTRID_TYPE",
            Self::SnsStdSensorAttridAvailable => "SNS_STD_SENSOR_ATTRID_AVAILABLE",
            Self::SnsStdSensorAttridVersion => "SNS_STD_SENSOR_ATTRID_VERSION",
            Self::SnsStdSensorAttridApi => "SNS_STD_SENSOR_ATTRID_API",
            Self::SnsStdSensorAttridRates => "SNS_STD_SENSOR_ATTRID_RATES",
            Self::SnsStdSensorAttridResolutions => "SNS_STD_SENSOR_ATTRID_RESOLUTIONS",
            Self::SnsStdSensorAttridFifoSize => "SNS_STD_SENSOR_ATTRID_FIFO_SIZE",
            Self::SnsStdSensorAttridActiveCurrent => {
                "SNS_STD_SENSOR_ATTRID_ACTIVE_CURRENT"
            }
            Self::SnsStdSensorAttridSleepCurrent => "SNS_STD_SENSOR_ATTRID_SLEEP_CURRENT",
            Self::SnsStdSensorAttridRanges => "SNS_STD_SENSOR_ATTRID_RANGES",
            Self::SnsStdSensorAttridOpModes => "SNS_STD_SENSOR_ATTRID_OP_MODES",
            Self::SnsStdSensorAttridDri => "SNS_STD_SENSOR_ATTRID_DRI",
            Self::SnsStdSensorAttridStreamSync => "SNS_STD_SENSOR_ATTRID_STREAM_SYNC",
            Self::SnsStdSensorAttridEventSize => "SNS_STD_SENSOR_ATTRID_EVENT_SIZE",
            Self::SnsStdSensorAttridStreamType => "SNS_STD_SENSOR_ATTRID_STREAM_TYPE",
            Self::SnsStdSensorAttridDynamic => "SNS_STD_SENSOR_ATTRID_DYNAMIC",
            Self::SnsStdSensorAttridHwId => "SNS_STD_SENSOR_ATTRID_HW_ID",
            Self::SnsStdSensorAttridRigidBody => "SNS_STD_SENSOR_ATTRID_RIGID_BODY",
            Self::SnsStdSensorAttridPlacement => "SNS_STD_SENSOR_ATTRID_PLACEMENT",
            Self::SnsStdSensorAttridPhysicalSensor => {
                "SNS_STD_SENSOR_ATTRID_PHYSICAL_SENSOR"
            }
            Self::SnsStdSensorAttridPhysicalSensorTests => {
                "SNS_STD_SENSOR_ATTRID_PHYSICAL_SENSOR_TESTS"
            }
            Self::SnsStdSensorAttridSelectedResolution => {
                "SNS_STD_SENSOR_ATTRID_SELECTED_RESOLUTION"
            }
            Self::SnsStdSensorAttridSelectedRange => {
                "SNS_STD_SENSOR_ATTRID_SELECTED_RANGE"
            }
            Self::SnsStdSensorAttridAdditionalLowLatencyRates => {
                "SNS_STD_SENSOR_ATTRID_ADDITIONAL_LOW_LATENCY_RATES"
            }
            Self::SnsStdSensorAttridPassiveRequest => {
                "SNS_STD_SENSOR_ATTRID_PASSIVE_REQUEST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_SENSOR_ATTRID_NAME" => Some(Self::SnsStdSensorAttridName),
            "SNS_STD_SENSOR_ATTRID_VENDOR" => Some(Self::SnsStdSensorAttridVendor),
            "SNS_STD_SENSOR_ATTRID_TYPE" => Some(Self::SnsStdSensorAttridType),
            "SNS_STD_SENSOR_ATTRID_AVAILABLE" => Some(Self::SnsStdSensorAttridAvailable),
            "SNS_STD_SENSOR_ATTRID_VERSION" => Some(Self::SnsStdSensorAttridVersion),
            "SNS_STD_SENSOR_ATTRID_API" => Some(Self::SnsStdSensorAttridApi),
            "SNS_STD_SENSOR_ATTRID_RATES" => Some(Self::SnsStdSensorAttridRates),
            "SNS_STD_SENSOR_ATTRID_RESOLUTIONS" => {
                Some(Self::SnsStdSensorAttridResolutions)
            }
            "SNS_STD_SENSOR_ATTRID_FIFO_SIZE" => Some(Self::SnsStdSensorAttridFifoSize),
            "SNS_STD_SENSOR_ATTRID_ACTIVE_CURRENT" => {
                Some(Self::SnsStdSensorAttridActiveCurrent)
            }
            "SNS_STD_SENSOR_ATTRID_SLEEP_CURRENT" => {
                Some(Self::SnsStdSensorAttridSleepCurrent)
            }
            "SNS_STD_SENSOR_ATTRID_RANGES" => Some(Self::SnsStdSensorAttridRanges),
            "SNS_STD_SENSOR_ATTRID_OP_MODES" => Some(Self::SnsStdSensorAttridOpModes),
            "SNS_STD_SENSOR_ATTRID_DRI" => Some(Self::SnsStdSensorAttridDri),
            "SNS_STD_SENSOR_ATTRID_STREAM_SYNC" => {
                Some(Self::SnsStdSensorAttridStreamSync)
            }
            "SNS_STD_SENSOR_ATTRID_EVENT_SIZE" => Some(Self::SnsStdSensorAttridEventSize),
            "SNS_STD_SENSOR_ATTRID_STREAM_TYPE" => {
                Some(Self::SnsStdSensorAttridStreamType)
            }
            "SNS_STD_SENSOR_ATTRID_DYNAMIC" => Some(Self::SnsStdSensorAttridDynamic),
            "SNS_STD_SENSOR_ATTRID_HW_ID" => Some(Self::SnsStdSensorAttridHwId),
            "SNS_STD_SENSOR_ATTRID_RIGID_BODY" => Some(Self::SnsStdSensorAttridRigidBody),
            "SNS_STD_SENSOR_ATTRID_PLACEMENT" => Some(Self::SnsStdSensorAttridPlacement),
            "SNS_STD_SENSOR_ATTRID_PHYSICAL_SENSOR" => {
                Some(Self::SnsStdSensorAttridPhysicalSensor)
            }
            "SNS_STD_SENSOR_ATTRID_PHYSICAL_SENSOR_TESTS" => {
                Some(Self::SnsStdSensorAttridPhysicalSensorTests)
            }
            "SNS_STD_SENSOR_ATTRID_SELECTED_RESOLUTION" => {
                Some(Self::SnsStdSensorAttridSelectedResolution)
            }
            "SNS_STD_SENSOR_ATTRID_SELECTED_RANGE" => {
                Some(Self::SnsStdSensorAttridSelectedRange)
            }
            "SNS_STD_SENSOR_ATTRID_ADDITIONAL_LOW_LATENCY_RATES" => {
                Some(Self::SnsStdSensorAttridAdditionalLowLatencyRates)
            }
            "SNS_STD_SENSOR_ATTRID_PASSIVE_REQUEST" => {
                Some(Self::SnsStdSensorAttridPassiveRequest)
            }
            _ => None,
        }
    }
}
/// Stream types
///
/// option (nanopb_enumopt).long_names = false;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdSensorStreamType {
    /// Used for Sensors that report data periodically.
    /// Example: accel, gyro, mag
    Streaming = 0,
    /// Used for Sensors that report data only on change in value.
    /// Example: proximity, hall
    OnChange = 1,
    /// Used for Sensors that have a single data event in reponse to a request.
    /// Example: SUID, motion detect
    SingleOutput = 2,
}
impl SnsStdSensorStreamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Streaming => "SNS_STD_SENSOR_STREAM_TYPE_STREAMING",
            Self::OnChange => "SNS_STD_SENSOR_STREAM_TYPE_ON_CHANGE",
            Self::SingleOutput => "SNS_STD_SENSOR_STREAM_TYPE_SINGLE_OUTPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_SENSOR_STREAM_TYPE_STREAMING" => Some(Self::Streaming),
            "SNS_STD_SENSOR_STREAM_TYPE_ON_CHANGE" => Some(Self::OnChange),
            "SNS_STD_SENSOR_STREAM_TYPE_SINGLE_OUTPUT" => Some(Self::SingleOutput),
            _ => None,
        }
    }
}
/// Rigid body types
///
/// option (nanopb_enumopt).long_names = false;
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdSensorRigidBodyType {
    /// Used for a Sensor mounted on the same rigid body as the display.
    Display = 0,
    /// Used for a Sensor mounted on the same rigid body as a keyboard.
    Keyboard = 1,
    /// Used for a Sensor that is mounted on an external device.
    External = 2,
}
impl SnsStdSensorRigidBodyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Display => "SNS_STD_SENSOR_RIGID_BODY_TYPE_DISPLAY",
            Self::Keyboard => "SNS_STD_SENSOR_RIGID_BODY_TYPE_KEYBOARD",
            Self::External => "SNS_STD_SENSOR_RIGID_BODY_TYPE_EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_SENSOR_RIGID_BODY_TYPE_DISPLAY" => Some(Self::Display),
            "SNS_STD_SENSOR_RIGID_BODY_TYPE_KEYBOARD" => Some(Self::Keyboard),
            "SNS_STD_SENSOR_RIGID_BODY_TYPE_EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
