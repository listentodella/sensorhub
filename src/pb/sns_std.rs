// This file is @generated by prost-build.
/// Base message payload, from which all other Request payloads must extend
/// The message will be delivered decoded within the Sensor API
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnsStdRequest {
    /// Batching is disabled by default
    #[prost(message, optional, tag = "1")]
    pub batching: ::core::option::Option<sns_std_request::BatchSpec>,
    /// Dynamic length payload, containing the actual data/configuration request
    /// This payload will need to be decoded separately, using the Sensor-specific
    /// header file. If the request does not contain any message body then this
    /// field is not present.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `sns_std_request`.
pub mod sns_std_request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BatchSpec {
        /// Logically a timer will be registered for this many microseconds.
        /// All events generated since the last timer expiration will be saved
        /// until the next timer has fired.  This period is interpreted as a maximum
        /// period specified by the client; events may be delivered to client at a
        /// faster rate (smaller batch period).
        /// A batch period of 0 indicates that no batching shall occur.
        #[prost(uint32, optional, tag = "1")]
        pub batch_period: ::core::option::Option<u32>,
        /// Do not store/return more than approximately this many microseconds of
        /// data upon a flush. The sensor can choose to drop old data but should
        /// always provide the latest flush period worth of data.
        /// Effective flush period may be smaller due to
        /// system constraints, or larger in the case of a concurrent client with a
        /// larger value.
        /// If less than batch_period, the Sensor may publish no
        /// events (depending on concurrent clients).
        /// Value defaults to value set for batch_period.
        #[prost(uint32, optional, tag = "2")]
        pub flush_period: ::core::option::Option<u32>,
        /// If flush_only = true, the sensor should
        /// only send data to the client on receiving a flush request or if the sensor
        /// cannot accumulate flush period worth of data.
        /// The absence of this field is equivalent to flush_only = false.
        /// \[default = false\];
        #[prost(bool, optional, tag = "3")]
        pub flush_only: ::core::option::Option<bool>,
        /// If max_batch = true for all requests, the sensor should operate at
        /// maximum batching capacity.
        /// The absence of this field is equivalent to max_batch = false.
        /// If a request has both max_batch = true and flush_only = true,
        /// flush_only takes precedence.
        /// \[default = false\];
        #[prost(bool, optional, tag = "4")]
        pub max_batch: ::core::option::Option<bool>,
    }
}
/// Query a Sensor for its list of attributes
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnsStdAttrReq {
    /// Register for updates when the attributes of a Sensor change
    /// This option is not presently supported
    #[prost(bool, optional, tag = "2")]
    pub register_updates: ::core::option::Option<bool>,
}
/// Contains all Sensor attributes; sent in response to an sns_std_attr_req,
/// or upon an attribute change to a registered Sensor
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnsStdAttrEvent {
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<super::sns_std_type::SnsStdAttr>,
}
/// An Error Event generated by a Sensor/Instance or the Framework
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SnsStdErrorEvent {
    /// SNS_STD_ERROR_NOT_AVAILABLE - Transitory error in the Sensor; some data
    ///     may have been lost or dropped, but streaming should resume.
    /// SNS_STD_ERROR_INVALID_STATE - Catastrophic error in the Sensor; do not
    ///     expect any further data.  Client may try sending enable-request again.
    /// SNS_STD_ERROR_NOT_SUPPORTED - Sensor received an unsupported request; or a
    ///     supported request at an unexpected time.
    #[prost(enumeration = "super::sns_std_type::SnsStdError", optional, tag = "1")]
    pub error: ::core::option::Option<i32>,
}
/// Framework-defined message IDs:
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SnsStdMsgid {
    SnsStdReserved = 0,
    /// Query a Sensor for all attributes
    /// @event sns_std_error_event
    SnsStdAttrReq = 1,
    /// Flush a Sensor.
    /// When a sensor receives a flush request it publishes any unpublished
    /// samples. The sensor always  publishes a SNS_STD_MSGID_SNS_STD_FLUSH_EVENT
    /// event to indicate completion of a flush request.
    /// All Sensors handle this flush request message.
    /// Empty Message
    /// @event sns_pb_flush_event
    SnsStdFlushReq = 2,
    /// All published attributes for a Sensor
    SnsStdAttrEvent = 128,
    /// Indicates no further events will be generated in response to flush req.
    /// Empty Message
    SnsStdFlushEvent = 129,
    /// Indicates an error has occurred
    SnsStdErrorEvent = 130,
}
impl SnsStdMsgid {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SnsStdReserved => "SNS_STD_MSGID_SNS_STD_RESERVED",
            Self::SnsStdAttrReq => "SNS_STD_MSGID_SNS_STD_ATTR_REQ",
            Self::SnsStdFlushReq => "SNS_STD_MSGID_SNS_STD_FLUSH_REQ",
            Self::SnsStdAttrEvent => "SNS_STD_MSGID_SNS_STD_ATTR_EVENT",
            Self::SnsStdFlushEvent => "SNS_STD_MSGID_SNS_STD_FLUSH_EVENT",
            Self::SnsStdErrorEvent => "SNS_STD_MSGID_SNS_STD_ERROR_EVENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SNS_STD_MSGID_SNS_STD_RESERVED" => Some(Self::SnsStdReserved),
            "SNS_STD_MSGID_SNS_STD_ATTR_REQ" => Some(Self::SnsStdAttrReq),
            "SNS_STD_MSGID_SNS_STD_FLUSH_REQ" => Some(Self::SnsStdFlushReq),
            "SNS_STD_MSGID_SNS_STD_ATTR_EVENT" => Some(Self::SnsStdAttrEvent),
            "SNS_STD_MSGID_SNS_STD_FLUSH_EVENT" => Some(Self::SnsStdFlushEvent),
            "SNS_STD_MSGID_SNS_STD_ERROR_EVENT" => Some(Self::SnsStdErrorEvent),
            _ => None,
        }
    }
}
